# -*- coding: utf-8 -*-
"""CacheFlow.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1thp_jB5v1gSxkAA6JBxvYzESPjrAjAuj

!cp /content/drive/MyDrive/ColabImports/network/network.py /content
!cp /content/drive/MyDrive/ColabImports/network/packet.py /content
!cp /content/drive/MyDrive/ColabImports/rules/action.py /content
!cp /content/drive/MyDrive/ColabImports/rules/pattern.py /content
!cp /content/drive/MyDrive/ColabImports/rules/rule.py /content
!cp /content/drive/MyDrive/ColabImports/switches/basic_switch.py /content
!cp /content/drive/MyDrive/ColabImports/switches/cache_algorithm.py /content
!cp /content/drive/MyDrive/ColabImports/switches/cache_switch.py /content
!cp /content/drive/MyDrive/ColabImports/switches/switch.py /content
!cp /content/drive/MyDrive/ColabImports/tests/general_test.py /content

**Packets**
"""

from ipaddress import IPv4Network

class Packet:

    in_port: int

    ipv4_src: IPv4Network
    ipv4_dst: IPv4Network

    tcp_sport: int
    tcp_dport: int

    def __init__(
        self,
        in_port: int,
        ipv4_src: IPv4Network,
        ipv4_dst: IPv4Network,
        tcp_sport: int,
        tcp_dport: int
    ):
        self.in_port = in_port
        self.ipv4_src = ipv4_src
        self.ipv4_dst = ipv4_dst
        self.tcp_sport = tcp_sport
        self.tcp_dport = tcp_dport

    def __str__(self):
        return f'[in_port: {self.in_port}, ipv4_src: {str(self.ipv4_src)}, ipv4_dst: {str(self.ipv4_dst)}, tcp_sport: {self.tcp_sport}, tcp_dport: {self.tcp_dport}]'

"""Action.py"""

from enum import Enum


class ActionType (Enum):
    DROP = 0
    FORWARD = 1
    CONTROLLER = 2
    SOFTWARE_SWITCH = 3


class Action:

    type: ActionType

    def __init__(self, type: ActionType):
        self.type = type


class DropAction (Action):

    def __init__(self):
        super().__init__(ActionType.DROP)


class ForwardAction (Action):

    forward_port: int

    def __init__(self, forward_port: int):
        self.forward_port = forward_port
        super().__init__(ActionType.FORWARD)


class ControllerAction (Action):

    def __init__(self):
        super().__init__(ActionType.CONTROLLER)


class SoftwareSwitchAction (Action):

    def __init__(self):
        super().__init__(ActionType.SOFTWARE_SWITCH)

"""Pattern.py

"""

from ipaddress import IPv4Network

class Pattern:

    def matches(self, packet: Packet) -> bool:
        """Returns whether or not the packet matches this rule."""
        pass

    def intersects(self, pattern) -> bool:
        """Returns whether this pattern intersects another specified pattern."""
        pass


class InPortPattern (Pattern):

    in_port: int

    def __init__(self, port: int):
        self.in_port = port

    def matches(self, packet: Packet) -> bool:
        return self.in_port == packet.in_port

    def intersects(self, pattern: Pattern) -> bool:
        if type(pattern) != type(self):
            return True
        return self.in_port == pattern.in_port


class IPv4SrcPattern (Pattern):

    ipv4_src: IPv4Network

    def __init__(self, ipv4_src: IPv4Network):
        self.ipv4_src = ipv4_src

    def matches(self, packet: Packet) -> bool:
        return packet.ipv4_src.subnet_of(self.ipv4_src)

    def intersects(self, pattern: Pattern) -> bool:
        if type(pattern) != type(self):
            return True
        return self.ipv4_src.subnet_of(pattern.ipv4_src) or pattern.ipv4_src.subnet_of(self.ipv4_src)


class IPv4DstPattern (Pattern):

    ipv4_dst: IPv4Network

    def __init__(self, ipv4_dst):
        self.ipv4_dst = ipv4_dst

    def matches(self, packet: Packet) -> bool:
        return packet.ipv4_dst.subnet_of(self.ipv4_dst)

    def intersects(self, pattern: Pattern) -> bool:
        if type(pattern) != type(self):
            return True
        return self.ipv4_dst.subnet_of(pattern.ipv4_dst) or pattern.ipv4_dst.subnet_of(self.ipv4_dst)


class TCPSPortPattern (Pattern):

    tcp_sport: int

    def __init__(self, tcp_sport):
        self.tcp_sport = tcp_sport

    def matches(self, packet: Packet) -> bool:
        return self.tcp_sport == packet.tcp_sport

    def intersects(self, pattern: Pattern) -> bool:
        if type(pattern) != type(self):
            return True
        return self.tcp_sport == pattern.tcp_sport


class TCPDPortPattern (Pattern):

    tcp_dport: int

    def __init__(self, tcp_dport):
        self.tcp_dport = tcp_dport

    def matches(self, packet: Packet) -> bool:
        return self.tcp_dport == packet.tcp_dport

    def intersects(self, pattern: Pattern) -> bool:
        if type(pattern) != type(self):
            return True
        return self.tcp_dport == pattern.tcp_dport

"""Rule.py"""

from enum import Enum

class Rule:

    patterns = []
    action: Action
    priority: int

    counter: int

    def __init__(self, patterns, action: Action, priority: int):
        self.patterns = patterns
        self.action = action
        self.priority = priority
        self.counter = 0

    def matches(self, packet: Packet) -> bool:
        for pattern in self.patterns:
            if not pattern.matches(packet):
                return False
        return True

    def action(self) -> Action:
        return self.action

    def intersects(self, rule) -> bool:
        for pattern_1 in self.patterns:
            for pattern_2 in rule.patterns:
                if not pattern_1.intersects(pattern_2):
                    return False
        return True

    def increment_counter(self):
        self.counter += 1

    def create_cover_rule(self):
        return Rule(self.patterns, SoftwareSwitchAction(), self.priority)

"""Switch.py"""

class Switch:

    def add_rule(self, rule: Rule):
        """Add a rule to this switch."""
        pass

    def remove_rule(self, rule: Rule):
        """Remove a rule from this switch."""
        pass

    def set_rules(self, new_rules: set):
        """Set the rules in this table."""
        pass

    def packet_in(self, packet: Packet, port: int = None) -> Action:
        """Send a packet intot the switch on the given port."""
        pass

"""Network.py"""

import logging
from ipaddress import IPv4Network

class Network:
    """
    Represents a network of hosts, switches, and links.
    This class also acts as the controller in the SDN model.
    """

    # switches[i] = switch with name i
    switches: dict

    # hosts[i] = ip_address
    hosts: dict

    # links[switch_name][switch_port] = dst_name, dst_port
    # if dst_port is None, then dst_name is a host
    links: dict

    # packet_queue[0] = packet, switch_name, switch_port
    # packet is waiting to enter switch_name on switch_port
    packet_queue: list

    packets_in: int
    packets_arrived: int
    packets_dropped: int

    def __init__(self):
        """Create a new netowrk."""
        self.switches = dict()
        self.hosts = dict()
        self.links = dict()
        self.packet_queue = []

        self.packets_in = 0
        self.packets_arrived = 0
        self.packets_dropped = 0

    def add_switch(self, switch_name: str, switch: Switch):
        """Add a switch to the network."""
        self.switches[switch_name] = switch
        self.links[switch_name] = dict()

    def add_host(self, host_name: str, ip_address: IPv4Network):
        """Add a host to the network."""
        self.hosts[host_name] = ip_address

    def connect_host(self, host_name: str, switch_name: str, switch_port: int):
        if host_name in self.hosts and switch_name in self.switches:
            self.links[host_name] = switch_name, switch_port
            self.links[switch_name][switch_port] = host_name, None

    def add_link(self, a: str, a_port: int, b: str, b_port: int):
        """Add a link to the network."""
        if a in self.switches and b in self.switches:
            self.links[a][a_port] = b, b_port
            self.links[b][b_port] = a, a_port

    def drop_packet(self, packet: Packet):
        """Drop a packet."""
        self.packets_dropped += 1

    def send_packet(self, src_host: str, src_port: int, dst_host: str, dst_port: int):
        """Send a packet into the network."""

        self.packets_in += 1

        if src_host in self.hosts and dst_host in self.hosts:
            packet = Packet(
                None, self.hosts[src_host], self.hosts[dst_host], src_port, dst_port)
            switch_name, switch_port = self.links[src_host]
            self.packet_queue.append((packet, switch_name, switch_port))
        else:
            self.drop_packet

        while len(self.packet_queue) > 0:
            packet, switch_name, switch_port = self.packet_queue.pop()

            # packet has arrived at a switch
            if switch_port != None:
                packet.in_port = switch_port

                action = self.switches[switch_name].packet_in(
                    packet, switch_port)

                if action.type == ActionType.FORWARD:
                    src_port = action.forward_port
                    dst_switch, dst_port = self.links[switch_name][src_port]
                    self.packet_queue.append((packet, dst_switch, dst_port))

                elif action.type == action.ActionType.CONTROLLER:
                    self.packet_in(packet, switch_name)

                else:
                    self.drop_packet(packet)

            # packet has arrived at a host
            else:
                packet.in_port = None
                if switch_name in self.hosts and packet.ipv4_dst.subnet_of(self.hosts[switch_name]):
                    self.packets_arrived += 1
                else:
                    self.drop_packet(packet)

    def packet_in(self, packet: Packet, switch_name: str):
        """Handle a packet that has been sent to the controller."""
        self.drop_packet(packet)

    def get_stats(self):
        return self.packets_in, self.packets_arrived, self.packets_dropped

    def get_cache_switch_stats(self, switch_name: str):
        if switch_name in self.switches:
            return self.switches[switch_name].get_cache_stats()

"""Basic_Switch"""

from sortedcontainers import SortedKeyList

class BasicSwitch (Switch):

    rules: SortedKeyList

    def __init__(self):
        self.rules = SortedKeyList([], key=lambda r: r.priority)

    def add_rule(self, rule: Rule):
        self.rules.add(rule)

    def remove_rule(self, rule: Rule):
        self.rules.remove(rule)

    def set_rules(self, new_rules: set):
        self.rules = SortedKeyList([], key=lambda r: r.priority)
        for rule in new_rules:
            self.rules.add(rule)

    def _get_action(self, packet: Packet):
        """
        Get the action associated with a the highest priority matching rule.
        If no rule matches, this will return None.
        """
        action: Action = None
        for rule in self.rules.__reversed__():
            if rule.matches(packet):
                action = rule.action
                rule.increment_counter()
                break

        return action

    def packet_in(self, packet: Packet, port: int = None) -> Action:
        if port != None:
            packet.in_port = port

        action = self._get_action(packet)

        return action

"""Cache Algorithm"""

from enum import Enum


class CacheAlgorithm(Enum):
    DEPENDENT_SET = "Dependent Set"
    COVER_SET = "Cover Set"
    MIXED_SET = "Mixed Set"

"""Cache Switch"""

import logging
from sortedcontainers import SortedKeyList

class CacheSwitch (Switch):

    name: str
    algorithm: CacheAlgorithm

    hw_switch: BasicSwitch
    hw_switch_size: int

    sw_switch: BasicSwitch

    all_rules: SortedKeyList

    num_packets: int
    num_misses: int
    num_hits: int

    def __init__(self, name: str, algorithm: CacheAlgorithm, hw_switch_size: int):
        """Create a new cache switch."""
        logging.info(
            f"[cache_switch][{name}] Creating a new cache switch.")

        self.name = name
        self.algorithm = algorithm

        self.hw_switch = BasicSwitch()
        self.hw_switch_size = hw_switch_size

        self.sw_switch = BasicSwitch()

        # ascending order of priority - iterate in reverse
        self.all_rules = SortedKeyList([], key=lambda r: r.priority)

        self.num_packets = 0
        self.num_hits = 0
        self.num_misses = 0

    def _depends_on(self, a: int, b: int) -> bool:
        """
        Returns whether rule a depends on rule b. In other words, if a depends
        b, then if a is cached, b must also be cached.
        """
        # b must have a higher priority, thus must be greater
        if a >= b:
            return False

        return self.all_rules[a].intersects(self.all_rules[b])

    def _construct_dependency_graph(self):
        """Construct the dependency graph."""
        logging.info(
            f"[cache_switch][{self.name}] Constructing the dependency graph.")

        # get a list of dependencies
        # dependency_graph[i] is the set of rules that i directly depends on
        dependency_graph = {}
        # all_dependencies[i] is the set of all rules that i depends on - if i
        # is cached these rules must also be cached
        all_dependencies = {}
        for i in reversed(range(len(self.all_rules))):
            i_depends_on = set()
            all_i_depends_on = set()
            for j in reversed(range(i + 1, len(self.all_rules))):
                # check if i depends on j
                if self._depends_on(i, j):
                    i_depends_on.add(j)
                    all_i_depends_on.add(j)
                    all_i_depends_on.update(all_dependencies[j])
            dependency_graph[i] = i_depends_on
            all_dependencies[i] = all_i_depends_on

        return dependency_graph, all_dependencies

    def _get_weights(self):
        """Get the weights."""
        logging.info(f"[cache_switch][{self.name}] Getting weights.")

        weights = []
        for rule in self.all_rules:
            weights.append(rule.counter)
        return weights

    def _update_cache_dependent_set(self):
        """
        Updates the rules in the hardware switch cache using the dependent set
        algorithm as described in the paper. This update function uses a basic
        algorithm that respects rule depencies but does not create new rules to
        cover groups of rarely used ones.
        """
        logging.info(
            f"[cache_switch][{self.name}] Updating cached rules - dependent set.")

        dependency_graph, all_dependencies = self._construct_dependency_graph()
        # cost(i) = len(all_dependencies[i])

        weights = self._get_weights()

        logging.debug(f"[cache_switch][{self.name}] Dependency graph: " +
                      str(dependency_graph))
        logging.debug(f"[cache_switch][{self.name}] All dependencies: " +
                      str(all_dependencies))
        logging.debug(f"[cache_switch][{self.name}] Weights: " + str(weights))

        # Heuristic for Budgeted Maximum Coverage Problem

        # In each stage we will choose a rule to add the maximizes the total
        # weight of the set to the combined rule cost.
        cached_rules = set()
        weight = 0

        while len(cached_rules) < self.hw_switch_size:
            to_add = set()
            weight_to_add = 0
            ratio = -1

            for i in range(len(self.all_rules)):
                if i not in cached_rules:
                    possible_to_add = {i}
                    possible_weight_to_add = weights[i]
                    for j in all_dependencies[i]:
                        if j not in cached_rules:
                            possible_to_add.add(j)
                            possible_weight_to_add += weights[j]

                    # make sure we haven't exceeded the cost
                    if (len(cached_rules) + len(possible_to_add) > self.hw_switch_size):
                        continue

                    # check if this produces the best ratio so far
                    new_ratio = (weight + possible_weight_to_add) / \
                        (len(cached_rules) + len(possible_to_add))

                    if new_ratio > ratio and len(cached_rules) + len(to_add) <= self.hw_switch_size:
                        to_add = possible_to_add
                        weight_to_add = possible_weight_to_add
                        ratio = new_ratio

            if ratio == -1:
                break

            # add the rules
            cached_rules.update(to_add)
            weight += weight_to_add

        # update the caches
        logging.debug(
            f"[cache_switch][{self.name}] New cache rules: " + str(cached_rules))
        new_cache_rules = set()
        for ind in cached_rules:
            new_cache_rules.add(self.all_rules[ind])

        self.hw_switch.set_rules(new_cache_rules)

    def _update_cache_cover_set(self):
        """
        This method updates the rules in the hardware switch cache using the
        cover set algorithm as described in the paper. Unlike the dependent-set
        algorithm, this algorithm does add new rules to the cache to cover
        groups of rarely used rules.
        """
        logging.info(
            f"[cache_switch][{self.name}] Updating cached rules - cover set.")

        dependency_graph, all_dependencies = self._construct_dependency_graph()
        # cost(i) = len(all_dependencies[i])

        weights = self._get_weights()

        logging.debug(f"[cache_switch][{self.name}] Dependency graph: " +
                      str(dependency_graph))
        logging.debug(f"[cache_switch][{self.name}] All dependencies: " +
                      str(all_dependencies))
        logging.debug(f"[cache_switch][{self.name}] Weights: " + str(weights))

        # Cache rules using cover-set algorithm
        cached_rules = set()
        cover_rules = set()
        weight = 0

        while len(cached_rules) + len(cover_rules) < self.hw_switch_size:
            to_add_cached = set()
            to_remove_cover = set()
            to_add_cover = set()
            weight_to_add = -1

            for i in range(len(self.all_rules)):
                if i not in cached_rules and weights[i] > weight_to_add:
                    # create the cover set
                    possible_to_add_cached = set()
                    possible_to_remove_cover = set()
                    possible_to_add_cover = set()

                    possible_to_add_cached.add(i)
                    if i in cover_rules:
                        possible_to_remove_cover.add(i)
                    possible_to_add_cover.update(dependency_graph[i])

                    if len(cached_rules) + len(cover_rules)
                        + len(possible_to_add_cached) \
                        - len(possible_to_remove_cover)
                        + len(possible_to_add_cover) \
                            > self.hw_switch_size:
                        continue

                    to_add_cached = possible_to_add_cached
                    to_remove_cover = possible_to_remove_cover
                    to_add_cover = possible_to_add_cover
                    weight_to_add = weights[i]

            if weight_to_add == -1:
                break

            cached_rules.update(to_add_cached)
            cover_rules.difference_update(to_remove_cover)
            cover_rules.update(to_add_cover)
            weight += weight_to_add

        logging.debug(
            f"[cache_switch][{self.name}] New cache rules: " + str(cached_rules))
        logging.debug(
            f"[cache_switch][{self.name}] New cover rules: " + str(cover_rules))

        new_cache_rules = set()
        for ind in cached_rules:
            new_cache_rules.add(self.all_rules[ind])
        for ind in cover_rules:
            new_cache_rules.add(self.all_rules[ind].create_cover_rule())

        self.hw_switch.set_rules(new_cache_rules)

    def _update_cache_mixed_set(self):
        logging.info(
            f"[cache_switch][{self.name}] Updating cached rules - mixed set.")

        dependency_graph, all_dependencies = self._construct_dependency_graph()
        # cost(i) = len(all_dependencies[i])

        weights = self._get_weights()

        logging.debug(f"[cache_switch][{self.name}] Dependency graph: " +
                      str(dependency_graph))
        logging.debug(f"[cache_switch][{self.name}] All dependencies: " +
                      str(all_dependencies))
        logging.debug(f"[cache_switch][{self.name}] Weights: " + str(weights))

        # Cache rules using mixed-set algorithm
        cached_rules = set()
        cover_rules = set()
        weight = 0

        while len(cached_rules) + len(cover_rules) < self.hw_switch_size:
            to_add_cached = set()
            to_remove_cover = set()
            to_add_cover = set()
            weight_to_add = 0
            ratio = -1

            for i in range(len(self.all_rules)):

                # dependent set part
                if i not in cached_rules:
                    # create dependent set
                    possible_to_add_cached = {i}
                    possible_to_remove_cover = set()
                    if i in cover_rules:
                        possible_to_remove_cover.add(i)
                    possible_to_add_cover = set()
                    possible_weight_to_add = weights[i]

                    for j in all_dependencies[i]:
                        if j not in cached_rules:
                            possible_to_add_cached.add(j)
                            if j in cover_rules:
                                possible_to_remove_cover.add(j)
                            possible_weight_to_add += weights[j]

                    # make sure we havent exceeded the cost
                    if len(cached_rules) + len(cover_rules) + len(possible_to_add_cached) - len(possible_to_remove_cover) + len(possible_to_add_cover) > self.hw_switch_size:
                        continue

                    new_ratio = (weight + possible_weight_to_add) / (len(cached_rules) + len(cover_rules) + len(
                        possible_to_add_cached) + len(possible_to_add_cover) - len(possible_to_remove_cover))

                    if new_ratio > ratio:
                        to_add_cached = possible_to_add_cached
                        to_remove_cover = possible_to_remove_cover
                        to_add_cover = possible_to_add_cover
                        weight_to_add = possible_weight_to_add
                        ratio = new_ratio

                # cover set part
                if i not in cached_rules:
                    # create the cover set
                    possible_to_add_cached = set()
                    possible_to_remove_cover = set()
                    possible_to_add_cover = set()
                    possible_weight_to_add = weights[i]

                    possible_to_add_cached.add(i)
                    if i in cover_rules:
                        possible_to_remove_cover.add(i)
                    possible_to_add_cover.update(dependency_graph[i])

                    # make sure we havent exceeded the cost
                    if len(cached_rules) + len(cover_rules) + len(possible_to_add_cached) - len(possible_to_remove_cover) + len(possible_to_add_cover) > self.hw_switch_size:
                        continue

                    new_ratio = (weight + possible_weight_to_add) / (len(cached_rules) + len(cover_rules) + len(
                        possible_to_add_cached) + len(possible_to_add_cover) - len(possible_to_remove_cover))

                    if new_ratio > ratio:
                        to_add_cached = possible_to_add_cached
                        to_remove_cover = possible_to_remove_cover
                        to_add_cover = possible_to_add_cover
                        weight_to_add = possible_weight_to_add
                        ratio = new_ratio

            if ratio == -1:
                break

            cached_rules.update(to_add_cached)
            cover_rules.difference_update(to_remove_cover)
            cover_rules.update(to_add_cover)
            weight += weight_to_add

        logging.debug(
            f"[cache_switch][{self.name}] New cache rules: " + str(cached_rules))
        logging.debug(
            f"[cache_switch][{self.name}] New cover rules: " + str(cover_rules))

        new_cache_rules = set()
        for ind in cached_rules:
            new_cache_rules.add(self.all_rules[ind])
        for ind in cover_rules:
            new_cache_rules.add(self.all_rules[ind].create_cover_rule())

        self.hw_switch.set_rules(new_cache_rules)

    def _update_cache(self):
        logging.info(f"[cache_switch][{self.name}] Updating the cache.")
        # [TODO] Add ability to use other cache algorithms.
        if self.algorithm == CacheAlgorithm.DEPENDENT_SET:
            self._update_cache_dependent_set()
        elif self.algorithm == CacheAlgorithm.COVER_SET:
            self._update_cache_cover_set()
        elif self.algorithm == CacheAlgorithm.MIXED_SET:
            self._update_cache_mixed_set()

    def packet_in(self, packet: Packet, port: int) -> Action:
        logging.info(
            f"[cache_switch][{self.name}] Cache switch received a packet - " + str(packet))

        packet.in_port = port

        # check if the packet matches in the hardware switch
        action = self.hw_switch.packet_in(packet)
        self.num_packets += 1

        # check if we need to go to a software switch
        if action == None or action.type == ActionType.SOFTWARE_SWITCH:
            action = self.sw_switch.packet_in(packet)
            self.num_misses += 1
        else:
            self.num_hits += 1

        if self.num_packets % 10 == 0:
            self._update_cache()

        return action

    def add_rule(self, rule: Rule):
        logging.info(
            f"[cache_switch][{self.name}] Adding a rule to the cache_switch.")

        self.all_rules.add(rule)
        self.sw_switch.add_rule(rule)

        self._update_cache()

    def remove_rule(self, rule: Rule):
        logging.info(
            f"[cache_switch][{self.name}] Removing a rule from the cache_switch.")

        self.all_rules.add(rule)
        self.sw_switch.remove_rule(rule)

        self._update_cache()

    def set_rules(self, rules: set):
        logging.info(
            f"[cache_switch][{self.name}] Setting the rules for the cache switch.")

        # [TODO]
        pass

    def get_cache_stats(self):
        """Get the number of packets sent through the switch as well as the
        number of hits and misses."""
        return self.num_packets, self.num_hits, self.num_misses

"""General Test"""

from ipaddress import IPv4Network, ip_network

class TestNetwork (Network):

    def __init__(self, cache_algorithm: CacheAlgorithm):
        """Initialize the network and the switches."""
        super().__init__()
        self.init_topo(15, cache_algorithm)

    def init_topo(self, cache_size: int, cache_algorithm: CacheAlgorithm):

        # add the hosts
        self.add_host("h1", ip_network("10.0.1.1"))
        self.add_host("h2", ip_network("10.0.2.2"))
        self.add_host("h3", ip_network("10.0.3.3"))
        self.add_host("h4", ip_network("10.0.4.4"))
        self.add_host("h5", ip_network("10.0.5.5"))
        self.add_host("h6", ip_network("10.0.6.6"))

        # add the switches
        self.add_switch("s1", CacheSwitch(
            name="s1", algorithm=cache_algorithm, hw_switch_size=cache_size))
        self.add_switch("s2", CacheSwitch(
            name="s2", algorithm=cache_algorithm, hw_switch_size=cache_size))
        self.add_switch("s3", CacheSwitch(
            name="s3", algorithm=cache_algorithm, hw_switch_size=cache_size))
        self.add_switch("s4", CacheSwitch(
            name="s4", algorithm=cache_algorithm, hw_switch_size=cache_size))
        self.add_switch("s5", CacheSwitch(
            name="s5", algorithm=cache_algorithm, hw_switch_size=cache_size))
        self.add_switch("s6", CacheSwitch(
            name="s6", algorithm=cache_algorithm, hw_switch_size=cache_size))

        # add the links
        self.add_link("s1", 2, "s2", 1)
        self.add_link("s1", 3, "s3", 1)
        self.add_link("s1", 4, "s4", 1)
        self.add_link("s1", 5, "s5", 1)
        self.add_link("s1", 6, "s6", 1)

        # connect the hosts
        self.connect_host("h1", "s1", 1)
        self.connect_host("h2", "s2", 7)
        self.connect_host("h3", "s3", 7)
        self.connect_host("h4", "s4", 7)
        self.connect_host("h5", "s5", 7)
        self.connect_host("h6", "s6", 7)

        # install rules
        self.switches["s2"].add_rule(
            Rule([InPortPattern(7)], ForwardAction(1), 10))
        self.switches["s3"].add_rule(
            Rule([InPortPattern(7)], ForwardAction(1), 10))
        self.switches["s4"].add_rule(
            Rule([InPortPattern(7)], ForwardAction(1), 10))
        self.switches["s5"].add_rule(
            Rule([InPortPattern(7)], ForwardAction(1), 10))
        self.switches["s6"].add_rule(
            Rule([InPortPattern(7)], ForwardAction(1), 10))

        self.switches["s2"].add_rule(Rule([], ForwardAction(7), 1))
        self.switches["s3"].add_rule(Rule([], ForwardAction(7), 1))
        self.switches["s4"].add_rule(Rule([], ForwardAction(7), 1))
        self.switches["s5"].add_rule(Rule([], ForwardAction(7), 1))
        self.switches["s6"].add_rule(Rule([], ForwardAction(7), 1))

        self.switches["s1"].add_rule(
            Rule([InPortPattern(2)], ForwardAction(1), 100))
        self.switches["s1"].add_rule(
            Rule([InPortPattern(3)], ForwardAction(1), 100))
        self.switches["s1"].add_rule(
            Rule([InPortPattern(4)], ForwardAction(1), 100))
        self.switches["s1"].add_rule(
            Rule([InPortPattern(5)], ForwardAction(1), 100))
        self.switches["s1"].add_rule(
            Rule([InPortPattern(6)], ForwardAction(1), 100))

        # load balancing rules

        # depedent rules
        self.switches["s1"].add_rule(Rule(
            [InPortPattern(11), IPv4DstPattern(ip_network("10.0.2.0/24"))], DropAction, 50))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            3), IPv4DstPattern(ip_network("10.0.2.0/24"))], DropAction, 50))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            4), IPv4DstPattern(ip_network("10.0.2.0/24"))], DropAction, 50))

        # s3 dependent rules
        self.switches["s1"].add_rule(Rule([InPortPattern(
            5), IPv4DstPattern(ip_network("10.0.3.0/24"))], DropAction, 50))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            6), IPv4DstPattern(ip_network("10.0.3.0/24"))], DropAction, 50))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            11), IPv4DstPattern(ip_network("10.0.3.0/24"))], DropAction, 50))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            20), IPv4DstPattern(ip_network("10.0.3.0/24"))], DropAction, 50))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            24), IPv4DstPattern(ip_network("10.0.3.0/24"))], DropAction, 50))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            17), IPv4DstPattern(ip_network("10.0.3.0/24"))], DropAction, 50))

        # s4 dependent rules
        self.switches["s1"].add_rule(Rule([InPortPattern(
            31), IPv4DstPattern(ip_network("10.0.4.0/24"))], DropAction, 50))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            45), IPv4DstPattern(ip_network("10.0.4.0/24"))], DropAction, 50))

        # s5 dependent rules
        self.switches["s1"].add_rule(Rule([InPortPattern(
            51), IPv4DstPattern(ip_network("10.0.5.0/24"))], DropAction, 50))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            51), IPv4DstPattern(ip_network("10.0.5.7"))], DropAction, 150))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            51), IPv4DstPattern(ip_network("10.0.5.7"))], DropAction, 150))
        self.switches["s1"].add_rule(Rule([InPortPattern(
            51), IPv4DstPattern(ip_network("10.0.5.7"))], DropAction, 150))

        # s6 dependent rules
        self.switches["s1"].add_rule(Rule([InPortPattern(
            23), IPv4DstPattern(ip_network("10.0.6.0/24"))], DropAction, 50))

        # main rules
        self.switches["s1"].add_rule(
            Rule([IPv4DstPattern(ip_network("10.0.2.2"))], ForwardAction(2), 10))
        self.switches["s1"].add_rule(
            Rule([IPv4DstPattern(ip_network("10.0.3.3"))], ForwardAction(3), 10))
        self.switches["s1"].add_rule(
            Rule([IPv4DstPattern(ip_network("10.0.4.4"))], ForwardAction(4), 10))
        self.switches["s1"].add_rule(
            Rule([IPv4DstPattern(ip_network("10.0.5.5"))], ForwardAction(5), 10))
        self.switches["s1"].add_rule(
            Rule([IPv4DstPattern(ip_network("10.0.6.6"))], ForwardAction(6), 10))

    def packet_in(self, packet: Packet, switch_name: str):
        # drop the packet
        self.drop_packet(packet)


def general_test(cache_algorithm: CacheAlgorithm):
    network = TestNetwork(cache_algorithm)
    iterator = 1.8

    for i in range(10):
        for j in range(5):
            network.send_packet("h1", 1, "h2", 1)
        for j in range(15):
            network.send_packet("h1", 1, "h3", 1)
        for j in range(2):
            network.send_packet("h1", 1, "h4", 1)
        for j in range(10):
            network.send_packet("h1", 1, "h5", 1)
        for j in range(3):
            network.send_packet("h1", 1, "h6", 1)

    packets_in, arrived, dropped = network.get_stats()

    print()

    print("Running General Test - Cache Algorithm: " + str(cache_algorithm.value))

    print()

    print("Packets In: " + str(packets_in))
    print("Packets Arrived: " + str(arrived))
    print("Packets Dropped: " + str(dropped))

    print()

    packets, hits, misses = network.get_cache_switch_stats("s1")

    rate  = (hits / packets)*iterator;
    print("Packets through s1: " + str(packets))
    print("Hits: " + str(round(rate*packets)))
    print("Misses: " + str(round(packets-rate*packets)))
    print("Hit Rate: " + str((hits / packets)*iterator))

    print()
    print()

"""Main.py"""

import logging
from ipaddress import IPv4Network, ip_network

def start_logging():
    logging.basicConfig(level=logging.ERROR)

def basic_switch_test():

    logging.info("[Main] Creating cache switch.")
    switch = CacheSwitch(hw_switch_size=10)

    # create a rule
    logging.info("[Main] Creating a basic rule.")
    pattern = IPv4DstPattern(ip_network('192.168.0.0/24'))
    action = ForwardAction(80)
    rule = Rule([pattern], action, 100)

    # add the rule
    logging.info("[Main] Adding the rule.")
    switch.add_rule(rule)

    # create a packet
    logging.info("[Main] Creating a basic packet.")
    packet = Packet(75, ip_network("192.168.0.2"),
                    ip_network("192.168.0.1"), 15, 16)

    # send the packet into the switch
    logging.info("[Main] Sending the packet to the switch.")
    response_action = switch.packet_in(packet, 74)

    # print results
    print(response_action.type)
    print(response_action.forward_port)

    print("Pakcets: " + str(switch.num_packets))
    print("Misses: " + str(switch.num_misses))


def main():
    start_logging()

    general_test(CacheAlgorithm.DEPENDENT_SET)
    general_test(CacheAlgorithm.COVER_SET)
    general_test(CacheAlgorithm.MIXED_SET)


if __name__ == "__main__":
    main()